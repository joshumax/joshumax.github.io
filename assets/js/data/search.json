[ { "title": "Running DOOM on a Hacked CaptionCall Landline", "url": "/general/2021/08/11/running-doom-on-captioncall.html", "categories": "general", "tags": "", "date": "2021-08-11 00:00:00 +0000", "snippet": "Recently, I came across a very interesting telephone service called CaptionCall. For those of you who don’t know about this service, it’s essentially a government-funded telephone captioning service that allowsdeaf or hard-of-hearing individuals to see a textual description of audio calls. But, more interesting than the serviceitself is the device they provide to their customers. It’s a fancy, Linux-based touchscreen landline running a proprietaryUI atop a buildroot userspace. It’s also quite capable, sporting an ARMv7 i.MX6 Quad SoC, 4GB of NAND, and a whopping 1GB!of DDR3. Naturally when finding this out, I just had to get DOOM running on it.Unfortunately for us, however, CaptionCall has no developer documentation for their device nor a way to accessa shell on the machine by default. Additionally, they provide no source code to their modified kernel tree. I have senta few emails to them after completing this for-fun project regarding GPL violations, but I have yet to hear back nordo I expect that I ever will. Because of these hindrances, I had to get a teensy bit creative in my process. This postshould cover most of my pains throughout my attempt, as well as offer guidance for anyone looking to hack their ownCaptionCall device (Note: you can find tons of these things on eBay for about $25 each!)Looking for an EntranceSo far, all I knew is that based on the firmware build ID this thing I had in my hands ran Linux. That’s really allI could find looking at the surface. Additionally, after hooking it up to my network and running a port scan againstthe device, nothing was open. Drat! Time to switch to plan b and open ‘er up! Removing the case was fairly trivial:3 philips-head screws were the only things securing the back in place; 2 on the bottom left and right, and one morehidden below an adhesive rubber strip. After prying the two halves apart, two headers on the PCB immediately caughtmy attention. The first looks like a standard ARM JTAG pad; however the leads from the traces to the SoC were cut.Kind of a bummer. Not unfixable, but I really didn’t feel like soldering tiny jumper wires and inevitably burning offmy fingertips. The second header definitely appeared familiar too. I guessed it was for UART access, and after probingit with a multimeter my assumption turned out to be correct!So, what can I do with UART on a CaptionCall, you ask? Apparently access the system console! However, there was onetiny catch. After completing booting, I was greeted with a friendly login prompt:U-Boot 2009.08 (Aug 31 2016 - 17:49:09)CPU: Freescale i.MX6 family TO0.1 at 792 MHz... REMOVED ...Bluetooth: RFCOMM TTY layer initializedBluetooth: RFCOMM socket layer initializedBluetooth: RFCOMM ver 1.11Bluetooth: BNEP (Ethernet Emulation) ver 1.3Bluetooth: BNEP filters: protocol multicastBluetooth: HIDP (Human Interface Emulation) ver 1.2lib80211: common routines for IEEE802.11 driversRegistering the dns_resolver key typeVFP support v0.3: implementor 41 architecture 3 part 30 variant 9 rev 4bonanza login:I tried root/root, root/toor, etc. but none of them worked. I was stuck until I could dump /etc/passwd and crackthe hashed login password. But to do that, I’d need to access the ramdisk! And to access the ramdisk, I need a shell!I was stuck in a catch-22 situation. All hope was not lost, however, because pressing ‘Escape’ within 1 second ofturning it on dropped me to a u-boot console! Still, the hardest part was yet to come…u-boot&amp;gt; Dumping the kernelU-boot comes with a few helpful utilities to make our life easier. This build let me play around with the loaderenvironment variables like the kernel cmdline. Initially I tried to change it to boot single-user and with a customramdisk, but alas the kernel they built had built-in boot arguments and ignored those from u-boot. After a bit moredigging I discovered this lovely articleon how to recover firmware through u-boot over serial (since mine lacked the tftp command).Basically, what I did was load the first kernel partition (since for some reason this has an A/B layout) to a knownmemory offset, and loop through each address value using md.b to print it over serial. This has the upside of beingrelatively simple to run, but the downsides of (a) being error-prone due to physical interference on the UART, and (b)being very, very, VERY slow. It took about 3 hours to dump the entire kernel partition over 115200 baud. And tomake matters even worse, sections of the dump were corrupted due to the issue from (a)! That meant I had to make additionaldumps over serial and merge them together in order to correct them! The whole process took about 9 hours, so I wrote ascript called uboot_hexdump_parser.py to do all the dirty work + error correction for me while I slept.After waking up the following morning I was greeted with my 32MB, error-free kernel partition dump! Running binwalk toldme that I had a compressed Linux kernel neatly tacked onto a u-boot uImage header. Usually, you add the kernel andramdisk separately to the uImage to make life easier, but CaptionCall decided to go the painful route and embed the ramdiskdirectly within the kernel. This caused a lot of suffering down the line, but I’ll cover that later. Binwalk had no issuestripping the xz-compressed ramdisk from the kernel and extracting it for me, huzzah! Poking around the files in /etcI learned the partition layout:# partition table of /dev/mmcblk0unit: sectors#---- U-Boot: 16 blocks for partition table -------------------------------------------------------#/dev/mmcblk0 : start=0, size=16 &amp;lt;---Primary partition table [dummy line] /dev/mmcblk0p1 : start=16, size=4080, Id=DA#---- U-Boot env ---------------------------------------------------------------------------------- /dev/mmcblk0p2 : start=4096, size=512, Id=DA#---- Kernel 1 ------------------------------------------------------------------------------------ /dev/mmcblk0p3 : start=4608, size=65536, Id=F0#---- extended container -------------------------------------------------------------------------- /dev/mmcblk0p4 : start=70144, size=7663100, Id=85#---- Kernel 2 ------------------------------------------------------------------------------------ /dev/mmcblk0p5 : start=70656, size=65536, Id=F0#---- Data ---------------------------------------------------------------------------------------- /dev/mmcblk0p6 : start=136192, size=7597052, Id=83Everything is run from the ramdisk and most of that 4GB EMMC I was talking about is mounted to /mnt/data and containsuser-stored contact info, help documents, images, recordings, etc. rather than a rootfs like I initially assumed. This meantif I wanted to change anything or stop the phone UI from loading on boot, I’d have to change the ramdisk. Nonetheless,I had gotten this far and I wanted to know what the default root password was. Running john took about 8 secondsto tell me the original unhashed root password was y4u8it. I tried that and was greeted with a busybox shell. So,I told myself, I’m definitely one step closer to getting DOOM working. :)Modifying the RamdiskCaptionCall’s proprietary UI started on boot and hogged the framebuffer, so I quickly realized it had to go. The problemwas that it was added in /etc/inittab to automatically restart when killed. And since the ramdisk was read-only I couldn’tjust comment it out from my root shell. Plus, even if I did manage to remount / as read-write, it wouldn’t persist pasta reboot! I had to figure out how to change the ramdisk at-will.This took me on an exciting adventure in learning how kernel decompression works under the hood. You see, there are two generaltypes of kernel images: “uncompressed” images (often named Image or vmlinux) which are your standard, run-of-the-mill kernels,and “compressed” images (often named *zImage or vmlinuz). For the compressed images, decompressor code (called piggy) isadded at the beginning of the file, and the rest of the kernel data is compressed using gzip, bzip2, xz, etc. It looks a bitlike this:-----------------| uImage header |-----------------| piggy.o |-----------------| || || Gzip&#39;d kernel || || ----------- || | Ramdisk | || ----------- || |-----------------As it also turns out, you can just remove the decompressor code, extract the kernel data following it, and it will workjust fine as if it was still compressed! That’s one less layer of encapsulation to worry about. Modying the ramdisk insidethe kernel image is a bit trickier. Linux provides two ELF symbols, __irf_start and __irf_end to mark the beginning and endof the embedded ramdisk, respectively. However, my kernel image wasn’t in ELF format. Fortune favored me again, and I founda neat utility called vmlinux-to-elf that converts all manner of mutilated kernelblobs to ELF format. With this I was able to grep the ramdisk boundary offsets and begin patching! In the end, I wrote a secondscript called uImage_rdpatch.sh that deals with everything from modifying the ramdisk to even patching the touchscreendriver (which, as I found through way too much trial-and-error, had an evdev bug that prevented it from working under X).My new ramdisk cleans up the inittab and also automatically runs any script called /mnt/data/init.sh on boot! Perfect formy next evil plan, which was creating a Debian chroot to auto-start X11, IceWM, and DOOM…The Glorious Debian Chroot!Since I really didn’t want to hassle with cross-compiling DOOM for an embedded buildroot ramdisk running an ancient version oflibc, I opted to use debootstrap and create an armel jessie chroot, which, unfortunately, is the last version of ARM Debianto support glibc 2.23 and the CaptionCall Linux 3.0.35 kernel version. Luckily, this part went without much hassle(other than debugging the extremely strange touchscreen issues I ended up having to patch in the kernel, hmph)! Using my l33tXorg.conf trial-and-error skills, I eventually wrangled fbdev, mesa, and evdev to load IceWM on the screen with touchscreen andkeypad support. A bit more hacking and audio, bluetooth, and finally GPIO support was complete within my chroot.Then finally, the moment of truth…It can run DOOM!!!The CodeIf you’d like to perform this hack yourself, I provide a pre-patched kernel, as well as all of the utilities listed in thispost over at my GitHub repository here. All that’srequired is for you to open the phone and connect a UART dongle to the plastic header, login using root:y4u8it, and finallywrite the patched kernel to NAND by typing dd if=kernel1.patched of=/dev/mmcblk0p3. Have fun and happy hacking!" }, { "title": "Building Wine 3.0 for Android", "url": "/general/2018/01/19/building-wine-3-0-on-android.html", "categories": "general", "tags": "", "date": "2018-01-19 00:00:00 +0000", "snippet": "Yesterday marked the official release of Wine 3.0, bringing a multitudeof bugfixes, support improvements, and long-awaited features. Among these is the initial release of the Androidsupport drivers for the Wine platform. Naturally, when I heard the news I was excited to try it out! However,I was disappointed to find a complete and utter lack of documentation on building it for Android. This post is acollection of test notes and build steps to jump right into getting Wine running on your ARM/ARM64/x86 Android,as well as Wine on Android development for potential contributors.Disclaimer: Wine on Android is still very much under development and may not work for all devices, architectures,and graphics drivers. Additionally, Wine Qemu integration for Android is not yet fully complete, meaning you willcurrently ONLY be able to run Win32 applications on x86 devices and WinRT applications on ARM devices.See https://forum.xda-developers.com/showthread.php?t=2092348 for a list of programs ported to WinRT.PrerequisitesIn order to build Wine for Android, you’re going to need a few prerequisites: For starters, you’re going to need gradle, which can easily be acquired on Debian-based distros by running sudo apt install gradle Additionally, you’re going to need to build Wine for your host system first, so go ahead and grab all the necessary dependencies. For Debian-based operating systems, that can be done by running sudo apt build-dep wine Next, you’re going to need the Android SDK. Installation instructions depend on your platform and more information on how to install it can be attained at the Android Studio website https://developer.android.com/studio/index.html. Once you’ve finished installing Android Studio, open SDK manager and install the Android 21 (5.0) SDK tools. When this is done, export the environment variable $ANDROID_HOME to point to the SDK manager directory. Finally, you’ll want to get the Android NDK to compile Wine for the Android platform. Information on how to install this component is over at https://developer.android.com/ndk/index.html. When you’ve installed the NDK somewhere, export the environment variable $NDK_ROOT to point to the top directory of the NDK (i.e. the one with ndk-build in it).BuildingOkay, so you made it this far. Congratulations!This guide assumes that all building will take place in ~/wine-android, so go ahead and create that:mkdir ~/wine-android &amp;amp;&amp;amp; cd ~/wine-androidNext, grab a copy of Wine from http://winehq.org and extract it:wget https://dl.winehq.org/wine/source/3.0/wine-3.0.tar.xztar xf wine-3.0.tar.xzNow you should have a directory called wine-3.0 in ~/wine-android, go ahead and copy it (we’re going to needto build a native version of Wine first).cp -r wine-3.0 wine-3.0-nativecd into it:cd wine-3.0-nativeAnd build Wine for your host system. A guide on how to do this can be found herebut basically the commands to build are as follows:For 32-bit host:./configureFor 64-bit host:./configure --enable-win64 # No use in building useless i686 supportNext run:makeand you’re done!Building for the host first is necessary because we’ll need everything in the tools/ directory to cross-compile.cd back to the parent directory:cd ..Now it’s time to get ready to cross-compile! Depending on what architecture you want, you’ll have to usea different toolchain. Some common ones have been listed:For 32-bit ARM targets:export TOOLCHAIN_VERSION=&quot;arm-linux-androideabi-4.9&quot;export TOOLCHAIN_TRIPLE=&quot;arm-linux-androideabi&quot;For 64-bit ARM targets:export TOOLCHAIN_VERSION=&quot;aarch64-linux-android-4.9&quot;export TOOLCHAIN_TRIPLE=&quot;aarch64-linux-android&quot;For 32-bit x86 targets:export TOOLCHAIN_VERSION=&quot;x86-4.9&quot;export TOOLCHAIN_TRIPLE=&quot;i686-linux-android&quot;When you’ve exported the proper toolchain version, build a standalone toolchain using the following command:$NDK_ROOT/build/tools/make-standalone-toolchain.sh --platform=android-21 --install-dir=android-toolchain --toolchain=$TOOLCHAIN_VERSIONThis should hopefully complete without error and create the directory android-toolchain/. Export it to your $PATH:export PATH=`pwd`/android-toolchain/bin:$PATHNext, we’re going to need to download and build Freetype2 for Android. Freetype is necessary to render fonts in Wine.Download and extract Freetype using the following commands:wget https://download.savannah.gnu.org/releases/freetype/freetype-2.6.tar.gztar xf freetype-2.6.tar.gzNow cd into the newly-created directory to begin cross-compiling Freetype.cd freetype-2.6Now that you’re in the source tree of Freetype, run the configure script like so:./configure --host=$TOOLCHAIN_TRIPLE --prefix=`pwd`/output --without-zlib --with-png=no --with-harfbuzz=noAfter that’s complete, build and install Freetype to output/:make -j`nproc` &amp;amp;&amp;amp; make installCongratulations! You’ve successfully compiled Freetype for Android, now onto Wine!cd ../wine-3.0Wine configuration is a bit trickier, but if we set a few environment variables it should work just fine.First, let’s work around an optimization bug for certain versions of gcc when compiling Wine:export CFLAGS=&quot;-O2&quot;Now we’re going to need to tell the configuration scripts where we placed the Freetype library and headers.This can be done by exporting their respective directory paths:export FREETYPE_CFLAGS=&quot;-I`pwd`/../freetype-2.6/output/include/freetype2&quot;export FREETYPE_LIBS=&quot;-L`pwd`/../freetype-2.6/output/lib&quot;Now run configure in the Wine directory like so:./configure --host=$TOOLCHAIN_TRIPLE host_alias=$TOOLCHAIN_TRIPLE \\ --with-wine-tools=../wine-3.0-native --prefix=`pwd`/dlls/wineandroid.drv/assetsThe configuration should work just fine, however if you get any errors related to Freetype, you likelyexported your Freetype2 build locations incorrectly. Assuming everything worked correctly,you can now build Wine for Android like so:make -j`nproc` &amp;amp;&amp;amp; make installIf there were no compilation errors, you can now proceed to copy the Freetype shared library you builtover to the Wine Android driver assets.# YOUR_ARCH will be the architecture code of the platform you&#39;re building for (e.g. armv7-a, x86, etc.)cp ../freetype-2.6/output/lib/libfreetype.so dlls/wineandroid.drv/assets/YOUR_ARCH/lib/Next, cd into the Wine Android driver directory to begin packaging:cd dlls/wineandroid.drv/There will already be an APK in this directory, but it’s missing the necessary assets, so clean up.make cleanNow run make again to build the proper APK:makeIf everything works correctly, you should have a file wine-debug.apk that’s ~50MB in size!Copy it over to your device’s storage, or install it using adb.IssuesOne of the biggest issues I’ve noticed so far is that Wine refuses to load the desktop shellon certain devices. This seems to be related to certain problems with some graphics hardware/drivers.Unfortunately there’s not a whole lot I can do about it at this point. I’m actively hacking the Winecodebase in order to try and fix this up. One notorious example of this is trying to load it onan Atom AVD using native graphics on desktop NVIDIA hardware. Disable native graphics to make it work.For phones and tablets that have trouble, you may have some luck toggling Force GPU Renderingin developer options.Another issue surrounds the Task Bar and Window sizing. On some devices the Start menu is unusableand the only way to access programs is through the Wine console. I’m working in getting this issuefixed up as it seems to be okay in the automated builds. As for the window sizing issue, just launchwinecfg.exe and set the display DPI to your liking.While Wine supports input through the touchscreen and virtual keyboard, it doesn’t open up automaticallywhen you select an input box. Once again, I’m working on getting this fixed. In the meantime, you canpair a bluetooth keyboard up to your device, or install Hacker&#39;s Keyboard and enable the persistentnotification to open the keyboard when it’s pressed.Finally, for those who compiled Wine for an ARM-based Android, in order to run WinRT applications, youwill need to make sure you have the tpidrurw patch applied to your device’s kernel. There’s a tool that youcan build to check this over at https://github.com/AndreRH/tpidrurw-test.For the LazyThere’s already some automated builds for Wine on Android on the official download site.Check them out here if your device is supported: https://dl.winehq.org/wine-builds/android." }, { "title": "How Torch broke ls and made me vulnerable (or the hidden dangers of LD_LIBRARY_PATH)", "url": "/general/2017/06/08/how-torch-broke-ls.html", "categories": "general", "tags": "", "date": "2017-06-08 00:00:00 +0000", "snippet": "So, today I decided to check out the firmware of a wireless router using the amazing utilityknown as binwalk. Nothing too unusual and everything seemed to work quite smoothly:Then I went to cd into the newly-extracted firmware directory, and that’s where it all went wrong…Immediately, I could tell something was up. Powerline was no longer working and I couldn’tsee anything resembling a bash prompt. I sheepishly typed in ls and saw this:How was this possible? My system was working just fine a second ago! I quicklyattempted to run strace to see if I could find out what was going on and hoped it’d helpfigure out what was happening here…Sure enough, for some odd reason I was trying to load libpthread from the current directoryrather than from /usr/lib64 where it normally resides on my machine. A quick check from thefile command and Caja validated that the issue was that the firmware I was extracting justhappened to have a rogue libpthread.so.0 sitting in the top directory:Moving back up a directory, of course, fixed the problem. Now the question that was on mymind was “WHY ON EARTH IS MY WORKSTATION TRYING TO LOAD LIBRARIES FROM $PWD?”A quick inspection of my LD_LIBRARY_PATH gave me:/home/joshua/torch/install/lib:/home/joshua/torch/install/lib:/home/joshua/torch/install/lib:Which seemed okay. Torch created that when it wrote to my .bashrc and nothing seemedparticularly out of the ordinary. But nonetheless, unexporting it “miraculously” fixedmy problem and I was able to browse the directory of the router’s extracted firmware.After a bit of research and playing around, I came across a startling fact:On many machines, Glibc’s ld.so will add the current working directory to the library searchpath on any LD_LIBRARY_PATH with a trailing colon. That means that one little : at the endwas causing every executable that requires any shared library to start its search in the currentdirectory that I started it in. Every git repository that I downloaded and ran a trusted command in,every directory I extracted from a tar file, every disk image that I mounted had the ability toinject a malicious shared library that ld.so would have happily loaded for the application thatrequired it. And because I installed Torch for machine learning work over a year ago, I had beencompletely vulnerable to this type of attack for a long time! I went to the Torch codebase to confirmthat it was really the culprit, and sure enough:Because my LD_LIBRARY_PATH was empty before I installed Torch, the export in torch-activateresults in a rogue colon being placed at the end of it, resulting in potential issues such as this.Any users of the Torch machine learning library should make sure their LD_LIBRARY_PATH is secure…" } ]
